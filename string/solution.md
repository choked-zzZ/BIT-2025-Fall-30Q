# 事先声明
本题解采用Markdown编写，如若网站不支持，可自行复制到Obsidian，Notion等软件或者是在线编辑器中查看
在题解的编写上借鉴了诸多前辈和同龄人的思路与观点，在此一并致谢！
题解难免有误 如有错误还请在评论区指出 感激不尽
如果有其他想法也可以在此讨论

## T6 A+B

二进制的竖式加法也一样啦 也就是要计算当前的位和进位而已 主要是仔细查看输出格式才可以
横线的个数是结果数字的长度+2 根据此来实现右对齐 在内容前输出合适的空格就好
先计算出结果数字 采用竖式加法 记录结果与进位 较为简单 不再细说

## T7 发言统计

前置知识：HashSet\HashMap
Hash也就是哈希 就像是数字世界的ID一样 是用来区分两个数据是否相同的简单方法
生成Hash值的函数叫做哈希函数HashFunction 一个好的哈希函数通常具有这些特征

- 一致性/确定性 对于同一个输入 输出的Hash值永远一致
- 均匀分布性 对于大量随机数据 输出的Hash值会尽可能均匀的分布在值域中
- 输出一般是定长的
- 找到下列内容会是十分困难的
  - 已知Hash值 找到原内容
  - 找到两个具有相同Hash值的不同内容（**这是存在的 但是对于某些哈希函数难以构造或寻找**）
  - 已知一个Hash值和原内容 找到另一个Hash值相同的不同内容

即使存在哈希碰撞Hash collision 也就是不同内容具有相同Hash值 但是在一般的算法问题中 除非出题人刻意构造 发生碰撞的概率是非常小的

有了以上知识我们就可以解决这道题了 使用C++里的unordered_set容器来解决

这个容器就像一个酒店 需要指定一个类型 这里是string类型 接收到一个string内容后 安排其前往它hash值对应的房间号，这样下次有相同的string进来后，hash也是相同的，不会额外占用房间 最后统计一共有多少房间被占用就好了
读取字符 筛选长度大于10的串 采用unordered_set容器来记录出现过的串种类 最后输出个数

## T8
本题较难 如果不能理解可先放弃 本题也不会详细讲解

铸币主播一开始没看到内存限制 用map记录完了 觉得这题描述怎么这么抽象 后来发现这题居然只允许512K 那我们就需要在内存上节约一点了

- 电话号码只能以3和6开头 最多会有$2 \times 10^6$个字符 字符的数量可能超过$10^6$  
- 出现重复的字符串不超过1500个 次数不超过1000 相比之下异常的少
所以我们考虑最坏的情况 需要记录$2 \times 10^6$个字符的出现情况（0代表没有出现 1代表已出现）
对于已经重复出现的 额外开一个1500大小的数组dup记录情况
如果监测到一个合法的字符串 查看是否为1 
- 如果不是则设为1 
- 如果是则检查dup内是否出现该串 
	- 如果没找到 则新增该串 重复次数设为2 
	- 如果找到了 将其重复次数增加1即可
	$2 \times 10^6$个数字的状态记录可以用bitset解决，如果使用C也可以用unsigned int之类解决
```C++
int act_num = atoi(s);
int val = act_num - (s[0] == '3' ? 3 : 5) * 1000000;
```
我们可以通过上面这个代码来将3000000-3999999， 6000000-6999999之间的数映射到0-1999999之间 内存就连续了
最后我们排序输出即可

## T9
**额外更新：Gemini告诉我这题并不是NP完全问题 似乎存在多项式复杂度解法（利用线性代数构建状态转移矩阵采用高斯消元） 读者自行查询验证**

**本题是思维题 如果无法想出解法 那么可以直接查看题解 然后自行编写代码**

算法题可以通过数据规模猜测 这里数据十分小 指数级别是可行的 这个读者可以自行积累经验

我们一行一行地按按钮，如果按完一行就不再考虑了
这样的话，为了这一行（i行)是完全熄灭的，下一行（i+1行）必须按下i行仍亮的按钮的下方的按钮 以此来熄灭i行仍亮的按钮 其他的按钮则一定不能按下
如此一来 i+1行的按钮要按什么 完全取决于i行哪些按钮仍亮 而这又是取决于i-1行的…… 直到第0行
但是我们不知道第0行该按什么按钮 于是我们枚举$2^n$种情况，依次验证即可由于n值较小 这个方案是可行的
时间复杂度$O(mn2^n)$  

## T10
**必须要交换**是没有意义的 因为没有规定不能交换相同字符 而"fattyhappy"字符串内有重复字符 交换任意两个相同字符即可。
用一个定长10字符滑动窗口来考虑，有三种情况
- 如果这个子字符串一字不差 那么交换两个重复的t或者p或者a或者y都可以
	- 例子fattyhappy 交换3 4字符
- 如果这个子字符串仅相差一个 那么考虑对不上的那个字符 在滑窗外是否有替代字符出现 如果有那么可以替换
	- 例子 afittyhappy 交换1 3字符
- 如果这个子字符串相差两个 那么仅需要考虑交换滑窗内的两个字符是否能构成目标字符串
	- 例子 afttyhappy 交换1 2字符
	情况一的字符 可以用哈希表预先遍历一遍字符串 获得fatyhp各个字符的出现位置 在需要的时候依次查询在滑窗外的字符位置交换就好了（并不耗时 最多查找11次就能找到……吧）